<?xml version="1.0" encoding="utf-8" ?>
<TrustFrameworkPolicy 
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
  xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
  xmlns="http://schemas.microsoft.com/online/cpim/schemas/2013/06" 
  PolicySchemaVersion="0.3.0.0" 
  TenantId="wabbit1317b2c.onmicrosoft.com" 
  PolicyId="B2C_1A_TrustFrameworkExtensions" 
  PublicPolicyUri="http://wabbit1317b2c.onmicrosoft.com/B2C_1A_TrustFrameworkExtensions">
  
  <BasePolicy>
    <TenantId>wabbit1317b2c.onmicrosoft.com</TenantId>
    <PolicyId>B2C_1A_TrustFrameworkBase</PolicyId>
  </BasePolicy>

  <BuildingBlocks>
    <ClaimsSchema>
    
      <!--Step 1. Add new claims to capture the custom user inputs on the UI -->
      <!-- the https status input, i.e. 200, 404 -->
      <ClaimType Id="httpStatusCode">
        <DisplayName>Http status code</DisplayName>
        <DataType>string</DataType>
        <UserHelpText>Enter a http status code</UserHelpText>
        <UserInputType>TextBox</UserInputType>
      </ClaimType>

      <!-- user checkbox selections, i.e. recieve updates, consent, etc -->
      <ClaimType Id="userPrefs">
        <DisplayName>User Terms and Conditions</DisplayName>
        <DataType>string</DataType>
        <UserInputType>CheckboxMultiSelect</UserInputType>
        <Restriction>
          <Enumeration Text="A" Value="A" SelectByDefault="false" />
          <Enumeration Text="B " Value="B" SelectByDefault="false" />
          <Enumeration Text="C" Value="C" SelectByDefault="false" />
        </Restriction>
      </ClaimType>      

    </ClaimsSchema>

    <!-- Optional: Oa. set the Display with the new user's email instead of defaulting to 'None' -->
    <ClaimsTransformations>
      <ClaimsTransformation Id="CreateDisplayNameFromEmail" TransformationMethod="FormatStringClaim">
        <InputClaims>
          <InputClaim ClaimTypeReferenceId="email" TransformationClaimType="inputClaim" />
        </InputClaims>
        <InputParameters>
          <InputParameter Id="stringFormat" DataType="string" Value="{0}" />
        </InputParameters>
        <OutputClaims>
          <OutputClaim ClaimTypeReferenceId="displayName" TransformationClaimType="outputClaim" />
        </OutputClaims>
      </ClaimsTransformation>
    </ClaimsTransformations>


  </BuildingBlocks>

  <ClaimsProviders>

    <ClaimsProvider>
      <DisplayName>Local Account SignIn</DisplayName>
      <TechnicalProfiles>
        
        <!--Prerequiste: Existing login-NonInteractive TechnicalProfile based on the starter pack -->
        <TechnicalProfile Id="login-NonInteractive">
          <Metadata>
            <Item Key="client_id">78b5ef62-91dc-45f0-8b89-fc0e0e063ec1</Item>
            <Item Key="IdTokenAudience">2470d8b2-4d33-4e4e-8376-80502b3993c0</Item>
          </Metadata>
          <InputClaims>
            <InputClaim ClaimTypeReferenceId="client_id" DefaultValue="78b5ef62-91dc-45f0-8b89-fc0e0e063ec1" />
            <InputClaim ClaimTypeReferenceId="resource_id" PartnerClaimType="resource" DefaultValue="2470d8b2-4d33-4e4e-8376-80502b3993c0" />
          </InputClaims>
        </TechnicalProfile>

        <!-- 2. Override the LocalAccountSignUpWithLogonEmail techProfile, i.e. the Sign Up page  -->
        <TechnicalProfile Id="LocalAccountSignUpWithLogonEmail">
          <Metadata>
            <!-- a. Disable email verification, i.e 'Send Verification Code'  -->
            <Item Key="EnforceEmailVerification">false</Item>
          </Metadata>          
          <InputClaims>
            <!-- b. Set the input claims that require a default value 
            Important: set the newPassword claim with a temporary passowrd that the 
            satisfies the b2c password policy, i.e. lowercase, uppercase and a number-->
            <InputClaim ClaimTypeReferenceId="newPassword" DefaultValue="tempPassword1" />
            <InputClaim ClaimTypeReferenceId="httpStatusCode" DefaultValue="200" />
          </InputClaims>
          <DisplayClaims>
            <!-- c. Set the display claims to show only the desired fields on the UI.
            Here we hide the newPassword and reenterPassword fields since we are setting a new user with temp password  -->
            <DisplayClaim ClaimTypeReferenceId="email" />
            <DisplayClaim ClaimTypeReferenceId="httpStatusCode" /> 
            <DisplayClaim ClaimTypeReferenceId="userPrefs" /> 
          </DisplayClaims>          
          <OutputClaims>
            <!-- d. copy all the output claims from the base and add the new fields in the preferred order -->
            <OutputClaim ClaimTypeReferenceId="objectId" />
            <OutputClaim ClaimTypeReferenceId="email" PartnerClaimType="Verified.Email" Required="true" />
            <OutputClaim ClaimTypeReferenceId="newPassword" Required="true" /> 
            <!-- <OutputClaim ClaimTypeReferenceId="reenterPassword" Required="true" /> -->
            <OutputClaim ClaimTypeReferenceId="executed-SelfAsserted-Input" DefaultValue="true" />
            <OutputClaim ClaimTypeReferenceId="authenticationSource" />
            <OutputClaim ClaimTypeReferenceId="newUser" />
            <OutputClaim ClaimTypeReferenceId="httpStatusCode" Required="true"/> <!-- new claim -->
            <OutputClaim ClaimTypeReferenceId="userPrefs" Required="true"/> <!-- new claim -->
          </OutputClaims>
          <ValidationTechnicalProfiles>
            <!-- e. copy the ValidationTechnicalProfiles from base and add new validationTechnicalProfile before 
              the AAD-UserWriteUsingLogonEmail tech profile so the account creation is dependent on the new tech profile-->
            <ValidationTechnicalProfile ReferenceId="httpstatus-api" /> 
            <!-- <ValidationTechnicalProfile ReferenceId="AAD-UserWriteUsingLogonEmail" /> 
              NOT sure why this must be commented out, but it's still being fired form the base 
              AND the order in which the VTP executes is still firing in the desired order.  
              If we don't comment this out, we get an odd error message saying the 'specified user already exists...and to chose another one' even though the 
              account is still created successfully  -->
          </ValidationTechnicalProfiles>
        </TechnicalProfile>

        <!-- 3. Add new TechnicalProfile to be used for validation -->
        <TechnicalProfile Id="httpstatus-api">
          <DisplayName>Return a http status code using an external rest api</DisplayName>
          <Protocol Name="Proprietary" Handler="Web.TPEngine.Providers.RestfulProvider, Web.TPEngine, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null" />
          <Metadata>
            <Item Key="ServiceUrl">https://bf0238f15a30.ngrok.io/api/generateHttpStatusApi</Item>
            <Item Key="AuthenticationType">None</Item>
            <Item Key="AllowInsecureAuthInProduction">true</Item>
            <Item Key="SendClaimsIn">Body</Item> <!-- incoming format -->
            <Item Key="ClaimsFormat">Body</Item> <!-- returning format -->
          </Metadata>
          <InputClaims>
            <!-- a. Add the input claims that will be sent to the rest api -->
            <InputClaim ClaimTypeReferenceId="email" PartnerClaimType="emailAddress"/><!--example of mapping email claim in policy to emailaddress property in api request  json  -->
            <InputClaim ClaimTypeReferenceId="httpStatusCode" />
            <InputClaim ClaimTypeReferenceId="userPrefs" />
          </InputClaims>
        </TechnicalProfile>

        <!-- Optional: Ob override the AAD-UserWriteUsingLogonEmail TP to include the claimsTransformation -->
        <TechnicalProfile Id="AAD-UserWriteUsingLogonEmail">
          <InputClaimsTransformations>
            <InputClaimsTransformation ReferenceId="CreateDisplayNameFromEmail" />
          </InputClaimsTransformations>
        </TechnicalProfile>

      </TechnicalProfiles>
    </ClaimsProvider>
  
  </ClaimsProviders>
</TrustFrameworkPolicy>
